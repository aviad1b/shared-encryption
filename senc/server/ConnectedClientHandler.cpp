/*********************************************************************
 * \file   ConnectedClientHandler.cpp
 * \brief  Implementation of ConnectedClientHandler class.
 * 
 * \author aviad1b
 * \date   December 2025, Kislev 5786
 *********************************************************************/

#include "ConnectedClientHandler.hpp"

namespace senc::server
{
	ConnectedClientHandler::ConnectedClientHandler(utils::Socket& sock,
												   const std::string& username,
												   Schema& schema,
												   IServerStorage& storage,
												   PacketReceiver& receiver,
												   PacketSender& sender,
												   UpdateManager& updateManager,
												   DecryptionsManager& decryptionsManager)
		: _sock(sock), _username(username),
		  _schema(schema), _storage(storage),
		  _receiver(receiver), _sender(sender),
		  _updateManager(updateManager), _decryptionsManager(decryptionsManager) { }

	void ConnectedClientHandler::loop()
	{
		Status status = Status::Connected;
		while (Status::Connected == status)
			status = iteration();
	}

	pkt::MakeUserSetResponse ConnectedClientHandler::make_userset(
		const std::string& creator,
		const std::vector<std::string>& owners,
		const std::vector<std::string>& regMembers,
		member_count_t ownersThreshold,
		member_count_t regMembersThreshold)
	{
		pkt::MakeUserSetResponse res{};

		auto allOwners = utils::views::join(owners, std::views::single(creator));
		res.user_set_id = _storage.new_userset(
			utils::ranges::strings(allOwners),
			utils::ranges::strings(regMembers),
			ownersThreshold, regMembersThreshold
		);

		// generate keys, and shards for each member
		PrivKey privKey1{}, privKey2{};
		std::tie(res.pub_key1, privKey1) = _schema.keygen();
		std::tie(res.pub_key2, privKey2) = _schema.keygen();

		auto poly1 = Shamir::sample_poly(privKey1, regMembersThreshold);
		auto poly2 = Shamir::sample_poly(privKey2, ownersThreshold);

		// retrieve shard IDs generated by storage
		auto getShardID = [&res, this](const std::string& username)
		{
			return _storage.get_shard_id(username, res.user_set_id);
		};
		auto creatorShardID = _storage.get_shard_id(creator, res.user_set_id);
		auto ownersShardsIDs = owners | std::views::transform(getShardID);
		auto regMembersShardsIDs = regMembers | std::views::transform(getShardID);

		// make private key shards for all members
		res.priv_key1_shard = Shamir::make_shard(poly1, creatorShardID);
		res.priv_key2_shard = Shamir::make_shard(poly2, creatorShardID);
		auto ownersShards1 = Shamir::make_shards(poly1, ownersShardsIDs);
		auto ownersShards2 = Shamir::make_shards(poly2, ownersShardsIDs);
		auto regMembersShards = Shamir::make_shards(poly1, regMembersShardsIDs);

		// for all non-creator members, register update for userset
		// (note that the zip view provides all elements by reference wrapper)
		for (auto [owner, shard1, shard2] : utils::views::zip(owners, ownersShards1, ownersShards2))
			_updateManager.register_owner(
				owner, res.user_set_id,
				res.pub_key1, res.pub_key2,
				std::move(shard1), std::move(shard2)
			);
		for (auto [regMember, shard] : utils::views::zip(regMembers, regMembersShards))
			_updateManager.register_reg_member(
				regMember, res.user_set_id,
				res.pub_key1, res.pub_key2,
				std::move(shard)
			);

		return res;
	}

	OperationID ConnectedClientHandler::initiate_decryption(const UserSetID& usersetID, Ciphertext&& ciphertext)
	{
		auto info = _storage.get_userset_info(usersetID);

		// register oepration in decryptions manager
		auto opid = _decryptionsManager.new_operation();

		// if both thresholds are zero, nothing to do, requires no members
		if (0 == info.owners_threshold && 0 == info.reg_members_threshold)
		{
			// in this case, finish operation and return.
			finish_operation(opid, DecryptionsManager::CollectedRecord(
				_username, usersetID,
				info.owners_threshold, info.reg_members_threshold
			));
			return opid;
		}

		// prepare decryption operation
		_decryptionsManager.prepare_operation(
			opid,
			_username, usersetID,
			std::move(ciphertext),
			info.owners_threshold,
			info.reg_members_threshold
		);

		// inform all relevant members of lookup
		auto members = utils::views::join(info.owners, info.reg_members) |
			std::views::filter([this](const std::string& s) { return s != _username; });
		for (const auto& member : members)
			_updateManager.register_lookup(member, opid);

		return opid;
	}

	void ConnectedClientHandler::continue_operation(const OperationID& opid,
													const DecryptionsManager::PrepareRecord& opPrepRecord)
	{
		// get shards IDs of all participants (including requester)
		const auto requesterShardID = _storage.get_shard_id(opPrepRecord.requester, opPrepRecord.userset_id);
		std::vector<PrivKeyShardID> ownersShardsIDs{ requesterShardID };
		std::vector<PrivKeyShardID> regMembersShardsIDs{ requesterShardID };
		for (const auto& owner : opPrepRecord.owners_found)
			ownersShardsIDs.push_back(_storage.get_shard_id(owner, opPrepRecord.userset_id));
		for (const auto& regMember : opPrepRecord.reg_members_found)
			regMembersShardsIDs.push_back(_storage.get_shard_id(regMember, opPrepRecord.userset_id));

		// for each member, make an update of ciphertext to decrypt
		for (const auto& owner : opPrepRecord.owners_found)
			_updateManager.register_decryption_participating(
				owner, opid,
				opPrepRecord.ciphertext,
				ownersShardsIDs
			);
		for (const auto& regMember : opPrepRecord.reg_members_found)
			_updateManager.register_decryption_participating(
				regMember, opid,
				opPrepRecord.ciphertext,
				regMembersShardsIDs
			);
	}

	void ConnectedClientHandler::finish_operation(const OperationID& opid,
												  DecryptionsManager::CollectedRecord&& opCollRecord)
	{
		const auto requesterShardID = _storage.get_shard_id(opCollRecord.requester, opCollRecord.userset_id);
		opCollRecord.shardsIDs1.push_back(requesterShardID);
		opCollRecord.shardsIDs2.push_back(requesterShardID);
		_updateManager.register_finished_decrpytion(
			opCollRecord.requester, opid,
			std::move(opCollRecord.parts1),
			std::move(opCollRecord.parts2),
			std::move(opCollRecord.shardsIDs1),
			std::move(opCollRecord.shardsIDs2)
		);
	}

	ConnectedClientHandler::Status ConnectedClientHandler::iteration()
	{
		auto req = _receiver.recv_request<
			pkt::LogoutRequest,
			pkt::MakeUserSetRequest,
			pkt::GetUserSetsRequest,
			pkt::GetMembersRequest,
			pkt::DecryptRequest,
			pkt::UpdateRequest,
			pkt::DecryptParticipateRequest,
			pkt::SendDecryptionPartRequest
		>(_sock);

		if (req.has_value())
			return std::visit(
				[this](auto& r) { return handle_request(r); },
				*req
			);

		// if reached here, bad request
		_sender.send_response(_sock, pkt::ErrorResponse{ "Bad request" });
		return Status::Connected;
	}

	ConnectedClientHandler::Status ConnectedClientHandler::handle_request(pkt::LogoutRequest& request)
	{
		(void)request;
		_sender.send_response(_sock, pkt::LogoutResponse{});
		return Status::Disconnected;
	}

	ConnectedClientHandler::Status ConnectedClientHandler::handle_request(pkt::MakeUserSetRequest& request)
	{
		pkt::MakeUserSetResponse response{};
		try
		{
			response = make_userset(
				_username,
				request.owners, request.reg_members,
				request.owners_threshold, request.reg_members_threshold
			);
		}
		catch (const ServerException& e)
		{
			_sender.send_response(_sock, pkt::ErrorResponse{
				std::string("Failed to create userset: ") + e.what()
			});
			return Status::Connected;
		}

		_sender.send_response(_sock, response);
		return Status::Connected;
	}

	ConnectedClientHandler::Status ConnectedClientHandler::handle_request(pkt::GetUserSetsRequest& request)
	{
		(void)request;

		std::vector<UserSetID> usersets;
		try { usersets = _storage.get_usersets(_username); }
		catch (const ServerException& e)
		{
			_sender.send_response(_sock, pkt::ErrorResponse{
				std::string("Failed to fetch usersets: ") + e.what()
			});
			return Status::Connected;
		}

		_sender.send_response(_sock, pkt::GetUserSetsResponse{
			std::move(usersets)
		});

		return Status::Connected;
	}

	ConnectedClientHandler::Status ConnectedClientHandler::handle_request(pkt::GetMembersRequest& request)
	{
		UserSetInfo info{};
		try { info = _storage.get_userset_info(request.user_set_id); }
		catch (const ServerException& e)
		{
			_sender.send_response(_sock, pkt::ErrorResponse{
				std::string("Failed to fetch userset members: ") + e.what()
			});
			return Status::Connected;
		}

		_sender.send_response(_sock, pkt::GetMembersResponse{
			.reg_members = std::move(info.reg_members),
			.owners = std::move(info.owners)
		});

		return Status::Connected;
	}

	ConnectedClientHandler::Status ConnectedClientHandler::handle_request(pkt::DecryptRequest& request)
	{
		OperationID opid{};

		try { opid = initiate_decryption(request.user_set_id, std::move(request.ciphertext)); }
		catch (const ServerException& e)
		{
			_sender.send_response(_sock, pkt::ErrorResponse{
				std::string("Failed to initiate decryption operation: ") + e.what()
			});
			return Status::Connected;
		}

		_sender.send_response(_sock, pkt::DecryptResponse{ opid });
		return Status::Connected;
	}

	ConnectedClientHandler::Status ConnectedClientHandler::handle_request(pkt::UpdateRequest& request)
	{
		(void)request;
		pkt::UpdateResponse response{};

		try { response = _updateManager.retrieve_updates(_username); }
		catch (const ServerException& e)
		{
			_sender.send_response(_sock, pkt::ErrorResponse{
				std::string("Failed to fetch updates: ") + e.what()
			});
			return Status::Connected;
		}

		_sender.send_response(_sock, response);
		return Status::Connected;
	}

	ConnectedClientHandler::Status ConnectedClientHandler::handle_request(pkt::DecryptParticipateRequest& request)
	{
		std::optional<DecryptionsManager::PrepareRecord> opPrepRecord;
		bool isRequired = false;

		try
		{
			std::tie(opPrepRecord, isRequired) = _decryptionsManager.register_participant(
				request.op_id,
				_username,
				_storage.user_owns_userset(_username, _decryptionsManager.get_operation_userset(request.op_id))
			);
		}
		catch (const ServerException& e)
		{
			_sender.send_response(_sock, pkt::ErrorResponse{
				std::string("Failed to fetch operation: ") + e.what()
			});
			return Status::Connected;
		}

		// if user isn't required for decryption, return fitting status
		if (!isRequired)
		{
			_sender.send_response(_sock, pkt::DecryptParticipateResponse{
				pkt::DecryptParticipateResponse::Status::NotRequired
			});
			return Status::Connected;
		}

		// if decryptions manager returned a prep record, continue to collection stage
		if (opPrepRecord.has_value())
		{
			try { continue_operation(request.op_id, *opPrepRecord); }
			catch (const ServerException& e) { /* TODO: Should probably inform operation initiator? */ }
		}

		// finally, send ack (ask client to send decryption part next (in fitting update))
		_sender.send_response(_sock, pkt::DecryptParticipateResponse{
			pkt::DecryptParticipateResponse::Status::SendPart
		});

		return Status::Connected;
	}

	ConnectedClientHandler::Status ConnectedClientHandler::handle_request(pkt::SendDecryptionPartRequest& request)
	{
		std::optional<DecryptionsManager::CollectedRecord> opCollRecord;

		try
		{
			auto userset = _decryptionsManager.get_operation_userset(request.op_id);
			auto shardID = _storage.get_shard_id(_username, userset);

			opCollRecord = _decryptionsManager.register_part(
				request.op_id,
				std::move(request.decryption_part),
				std::move(shardID),
				_storage.user_owns_userset(_username, userset)
			);
		}
		catch (const ServerException& e)
		{
			_sender.send_response(_sock, pkt::ErrorResponse{
				std::string("Failed to fetch operation: ") + e.what()
			});
			return Status::Connected;
		}

		// if decryptions manager returned collection record, finalize operation
		if (opCollRecord.has_value())
		{
			try { finish_operation(request.op_id, std::move(*opCollRecord)); }
			catch (const ServerException& e) { /* TODO: Should probably inform operation initiator? */ }
		}

		// finally, send ack
		_sender.send_response(_sock, pkt::SendDecryptionPartResponse{});

		return Status::Connected;
	}
}
